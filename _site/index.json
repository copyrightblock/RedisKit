{
  "README.html": {
    "href": "README.html",
    "title": "RedisKit | RedisKit",
    "summary": "RedisKit A production-ready, enterprise-grade Redis library for .NET 9 with advanced caching, pub/sub, and streaming features. \uD83D\uDE80 Features Core Features Caching: Generic Get, Set, Delete operations with TTL support Batch Operations: GetMany and SetMany for improved performance Key Prefixing: Support for cache key prefixes Pub/Sub: Type-safe publishing and subscribing with advanced pattern matching Streaming: Redis Streams support with consumer groups and retry mechanisms Multiple Serializers: JSON, MessagePack support Dependency Injection: Full support with .NET DI container High Performance Logging: Source generator based logging with EventId support Async/Await: Full async/await support with CancellationToken Enterprise Features \uD83D\uDD04 Circuit Breaker Pattern: Automatic failure detection and recovery \uD83D\uDCC8 Advanced Retry Strategies: Multiple backoff strategies (Exponential, Decorrelated Jitter, etc.) \uD83C\uDFE5 Health Monitoring: Automatic health checks with auto-reconnection \uD83C\uDFAF Pattern Matching: Redis glob pattern support (*, ?, [abc], [^abc], [a-z]) \uD83E\uDDF9 Memory Leak Prevention: Automatic cleanup of inactive handlers \uD83D\uDCCA Statistics & Monitoring: Built-in metrics for subscriptions and connections ⚡ High Performance: Optimized with concurrent collections and minimal allocations \uD83D\uDD10 Thread Safety: All operations are thread-safe \uD83D\uDCE6 Installation Install the package via NuGet: dotnet add package RedisKit \uD83C\uDFAF Quick Start Minimal Setup using RedisKit.Extensions; var builder = WebApplication.CreateBuilder(args); // Add Redis services with minimal configuration builder.Services.AddRedisServices(options => { options.ConnectionString = \"localhost:6379\"; }); var app = builder.Build(); // Use in your controllers or services app.MapGet(\"/cache/{key}\", async (string key, IRedisCacheService cache) => { var value = await cache.GetAsync<string>(key); return value ?? \"Not found\"; }); app.Run(); \uD83D\uDC76 Getting Started - Hello Redis! Your First Redis Cache using RedisKit.Extensions; using RedisKit.Interfaces; // 1. Setup - Add to your Program.cs var builder = WebApplication.CreateBuilder(args); builder.Services.AddRedisServices(options => { options.ConnectionString = \"localhost:6379\"; }); var app = builder.Build(); // 2. Simple String Cache app.MapPost(\"/hello/{name}\", async (string name, IRedisCacheService cache) => { // Store a simple string await cache.SetAsync($\"greeting:{name}\", $\"Hello, {name}!\", TimeSpan.FromMinutes(5)); return $\"Greeting saved for {name}\"; }); app.MapGet(\"/hello/{name}\", async (string name, IRedisCacheService cache) => { // Retrieve the string var greeting = await cache.GetAsync<string>($\"greeting:{name}\"); return greeting ?? \"No greeting found\"; }); app.Run(); Counter Example - Increment Values public class CounterService { private readonly IRedisCacheService _cache; public CounterService(IRedisCacheService cache) { _cache = cache; } public async Task<int> IncrementVisitCountAsync(string page) { var key = $\"visits:{page}\"; // Get current count var currentCount = await _cache.GetAsync<int?>(key) ?? 0; // Increment and save currentCount++; await _cache.SetAsync(key, currentCount, TimeSpan.FromDays(30)); return currentCount; } } Simple User Session public class SessionService { private readonly IRedisCacheService _cache; public SessionService(IRedisCacheService cache) { _cache = cache; } // Store user session public async Task CreateSessionAsync(string sessionId, string userId, string userName) { var session = new UserSession { UserId = userId, UserName = userName, LoginTime = DateTime.UtcNow }; // Session expires in 20 minutes await _cache.SetAsync($\"session:{sessionId}\", session, TimeSpan.FromMinutes(20)); } // Get user session public async Task<UserSession?> GetSessionAsync(string sessionId) { return await _cache.GetAsync<UserSession>($\"session:{sessionId}\"); } // Extend session public async Task ExtendSessionAsync(string sessionId) { var session = await GetSessionAsync(sessionId); if (session != null) { // Reset expiration to 20 minutes await _cache.ExpireAsync($\"session:{sessionId}\", TimeSpan.FromMinutes(20)); } } } public class UserSession { public string UserId { get; set; } public string UserName { get; set; } public DateTime LoginTime { get; set; } } \uD83D\uDD27 Configuration Basic Configuration services.AddRedisServices(options => { options.ConnectionString = \"localhost:6379\"; options.DefaultTtl = TimeSpan.FromHours(1); options.CacheKeyPrefix = \"myapp:\"; options.Serializer = SerializerType.MessagePack; // or JSON }); Advanced Configuration services.AddRedisServices(options => { options.ConnectionString = \"localhost:6379\"; options.DefaultTtl = TimeSpan.FromHours(1); options.CacheKeyPrefix = \"myapp:\"; // Retry Configuration options.RetryConfiguration = new RetryConfiguration { MaxAttempts = 3, Strategy = BackoffStrategy.ExponentialWithJitter, InitialDelay = TimeSpan.FromSeconds(1), MaxDelay = TimeSpan.FromSeconds(30), JitterFactor = 0.2 // 20% jitter }; // Circuit Breaker options.CircuitBreaker = new CircuitBreakerSettings { Enabled = true, FailureThreshold = 5, BreakDuration = TimeSpan.FromSeconds(30), SuccessThreshold = 2 }; // Health Monitoring options.HealthMonitoring = new HealthMonitoringSettings { Enabled = true, CheckInterval = TimeSpan.FromSeconds(30), AutoReconnect = true, ConsecutiveFailuresThreshold = 3 }; // Connection Timeouts options.TimeoutSettings = new ConnectionTimeoutSettings { ConnectTimeout = TimeSpan.FromSeconds(5), SyncTimeout = TimeSpan.FromSeconds(5), AsyncTimeout = TimeSpan.FromSeconds(5), KeepAlive = TimeSpan.FromSeconds(60) }; }); \uD83D\uDCDA Basic Usage Examples Simple Caching public class ProductService { private readonly IRedisCacheService _cache; public ProductService(IRedisCacheService cache) { _cache = cache; } public async Task<Product?> GetProductAsync(int productId) { var cacheKey = $\"product:{productId}\"; // Try to get from cache var cached = await _cache.GetAsync<Product>(cacheKey); if (cached != null) return cached; // Load from database var product = await LoadFromDatabaseAsync(productId); // Cache for 1 hour if (product != null) { await _cache.SetAsync(cacheKey, product, TimeSpan.FromHours(1)); } return product; } public async Task InvalidateProductAsync(int productId) { await _cache.DeleteAsync($\"product:{productId}\"); } } Basic Pub/Sub public class NotificationService { private readonly IRedisPubSubService _pubSub; private readonly ILogger<NotificationService> _logger; public NotificationService(IRedisPubSubService pubSub, ILogger<NotificationService> logger) { _pubSub = pubSub; _logger = logger; } // Publisher public async Task SendNotificationAsync(string userId, string message) { var notification = new UserNotification { UserId = userId, Message = message, Timestamp = DateTime.UtcNow }; await _pubSub.PublishAsync($\"notifications:{userId}\", notification); } // Subscriber public async Task StartListeningAsync(string userId) { await _pubSub.SubscribeAsync<UserNotification>( $\"notifications:{userId}\", async (notification, ct) => { _logger.LogInformation(\"Received notification for user {UserId}: {Message}\", notification.UserId, notification.Message); // Process notification await ProcessNotificationAsync(notification); }); } } public class UserNotification { public string UserId { get; set; } = string.Empty; public string Message { get; set; } = string.Empty; public DateTime Timestamp { get; set; } } Batch Operations public class BulkOperationService { private readonly IRedisCacheService _cache; public BulkOperationService(IRedisCacheService cache) { _cache = cache; } public async Task<Dictionary<int, Product?>> GetProductsAsync(int[] productIds) { // Generate cache keys var keys = productIds.Select(id => $\"product:{id}\"); // Get all products in one operation var cached = await _cache.GetManyAsync<Product>(keys); var result = new Dictionary<int, Product?>(); var missingIds = new List<int>(); // Check what we found in cache foreach (var productId in productIds) { var key = $\"product:{productId}\"; if (cached.TryGetValue(key, out var product) && product != null) { result[productId] = product; } else { missingIds.Add(productId); } } // Load missing from database if (missingIds.Any()) { var products = await LoadProductsFromDatabaseAsync(missingIds); // Cache them var toCache = new Dictionary<string, Product>(); foreach (var product in products) { result[product.Id] = product; toCache[$\"product:{product.Id}\"] = product; } await _cache.SetManyAsync(toCache, TimeSpan.FromHours(1)); } return result; } } \uD83D\uDE80 Advanced Usage Examples Pattern-Based Subscriptions public class GameEventService { private readonly IRedisPubSubService _pubSub; private readonly ILogger<GameEventService> _logger; private SubscriptionToken? _token; public GameEventService(IRedisPubSubService pubSub, ILogger<GameEventService> logger) { _pubSub = pubSub; _logger = logger; } public async Task StartMonitoringAsync() { // Subscribe to all game events using pattern _token = await _pubSub.SubscribePatternAsync<GameEvent>( \"game:*:events\", async (gameEvent, ct) => { _logger.LogInformation(\"Game {GameId} - Event: {EventType}\", gameEvent.GameId, gameEvent.EventType); switch (gameEvent.EventType) { case \"player_joined\": await HandlePlayerJoinedAsync(gameEvent); break; case \"game_started\": await HandleGameStartedAsync(gameEvent); break; case \"game_ended\": await HandleGameEndedAsync(gameEvent); break; } }); // You can also subscribe with channel metadata await _pubSub.SubscribePatternWithChannelAsync<GameEvent>( \"game:*:critical\", async (gameEvent, channel, ct) => { // Extract game ID from channel name var parts = channel.Split(':'); var gameId = parts[1]; _logger.LogCritical(\"Critical event in game {GameId}: {Message}\", gameId, gameEvent.Message); await SendAlertAsync(gameId, gameEvent); }); } public async Task StopMonitoringAsync() { if (_token != null) { await _token.UnsubscribeAsync(); } } } Redis Streams with Consumer Groups public class OrderProcessingService : BackgroundService { private readonly IRedisStreamService _streams; private readonly ILogger<OrderProcessingService> _logger; public OrderProcessingService(IRedisStreamService streams, ILogger<OrderProcessingService> logger) { _streams = streams; _logger = logger; } protected override async Task ExecuteAsync(CancellationToken stoppingToken) { // Create consumer group await _streams.CreateConsumerGroupAsync(\"orders\", \"order-processors\"); while (!stoppingToken.IsCancellationRequested) { try { // Read messages from stream var messages = await _streams.ReadGroupAsync<Order>( \"orders\", \"order-processors\", \"processor-1\", count: 10, cancellationToken: stoppingToken); foreach (var message in messages) { try { await ProcessOrderAsync(message.Data); // Acknowledge message await _streams.AcknowledgeAsync(\"orders\", \"order-processors\", message.Id); } catch (Exception ex) { _logger.LogError(ex, \"Failed to process order {OrderId}\", message.Data?.OrderId); // Message will be retried } } // Process pending messages (retry failed ones) var retryResult = await _streams.RetryPendingMessagesAsync<Order>( \"orders\", \"order-processors\", \"processor-1\", async (order) => { await ProcessOrderAsync(order); return true; // Success }, cancellationToken: stoppingToken); if (retryResult.FailureCount > 0) { _logger.LogWarning(\"Failed to process {Count} orders, moved to DLQ\", retryResult.DeadLetterCount); } } catch (Exception ex) { _logger.LogError(ex, \"Error in order processing loop\"); await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken); } } } private async Task ProcessOrderAsync(Order? order) { if (order == null) return; _logger.LogInformation(\"Processing order {OrderId}\", order.OrderId); // Process the order await Task.Delay(100); // Simulate work // Publish completion event await _pubSub.PublishAsync($\"orders:{order.OrderId}:completed\", new OrderCompleted { OrderId = order.OrderId, CompletedAt = DateTime.UtcNow }); } } Cache-Aside Pattern with Statistics public class CachedRepository<T> where T : class, IEntity { private readonly IRedisCacheService _cache; private readonly ILogger<CachedRepository<T>> _logger; private readonly string _entityName; private long _hits = 0; private long _misses = 0; public CachedRepository(IRedisCacheService cache, ILogger<CachedRepository<T>> logger) { _cache = cache; _logger = logger; _entityName = typeof(T).Name.ToLower(); } public async Task<T?> GetByIdAsync(string id, Func<Task<T?>> dataLoader) { var key = $\"{_entityName}:{id}\"; // Try cache first var cached = await _cache.GetAsync<T>(key); if (cached != null) { Interlocked.Increment(ref _hits); return cached; } Interlocked.Increment(ref _misses); // Load from source var entity = await dataLoader(); if (entity != null) { // Cache with sliding expiration await _cache.SetAsync(key, entity, TimeSpan.FromMinutes(15)); } return entity; } public async Task<T> GetOrCreateAsync(string id, Func<Task<T>> factory) { var key = $\"{_entityName}:{id}\"; var cached = await _cache.GetAsync<T>(key); if (cached != null) { Interlocked.Increment(ref _hits); return cached; } Interlocked.Increment(ref _misses); // Use distributed lock to prevent cache stampede var lockKey = $\"lock:{key}\"; var lockAcquired = await _cache.SetAsync( lockKey, \"locked\", TimeSpan.FromSeconds(30), when: When.NotExists); if (lockAcquired) { try { // Double-check after acquiring lock cached = await _cache.GetAsync<T>(key); if (cached != null) return cached; // Create new entity var entity = await factory(); await _cache.SetAsync(key, entity, TimeSpan.FromMinutes(15)); return entity; } finally { await _cache.DeleteAsync(lockKey); } } else { // Wait for other thread to populate cache await Task.Delay(100); return await GetByIdAsync(id, factory) ?? await factory(); } } public CacheStatistics GetStatistics() { var total = _hits + _misses; return new CacheStatistics { Hits = _hits, Misses = _misses, HitRate = total > 0 ? (double)_hits / total : 0 }; } } public interface IEntity { string Id { get; } } public class CacheStatistics { public long Hits { get; set; } public long Misses { get; set; } public double HitRate { get; set; } } \uD83C\uDFA8 Custom Serializer Implementation Creating a Custom Serializer using RedisKit.Serialization; using ProtoBuf; // Custom Protobuf serializer public class ProtobufRedisSerializer : IRedisSerializer { public string Name => \"Protobuf\"; public Task<byte[]> SerializeAsync<T>(T value, CancellationToken cancellationToken = default) where T : class { if (value == null) return Task.FromResult(Array.Empty<byte>()); using var stream = new MemoryStream(); Serializer.Serialize(stream, value); return Task.FromResult(stream.ToArray()); } public Task<T?> DeserializeAsync<T>(byte[] data, CancellationToken cancellationToken = default) where T : class { if (data == null || data.Length == 0) return Task.FromResult<T?>(null); using var stream = new MemoryStream(data); var result = Serializer.Deserialize<T>(stream); return Task.FromResult<T?>(result); } public Task<object?> DeserializeAsync(byte[] data, Type type, CancellationToken cancellationToken = default) { if (data == null || data.Length == 0) return Task.FromResult<object?>(null); using var stream = new MemoryStream(data); var result = Serializer.Deserialize(type, stream); return Task.FromResult(result); } } // Register custom serializer public class CustomSerializerFactory : IRedisSerializerFactory { public IRedisSerializer Create(SerializerType type) { return type switch { SerializerType.Custom => new ProtobufRedisSerializer(), _ => RedisSerializerFactory.Create(type) }; } } Using Custom Serializer // Option 1: Register globally services.AddRedisServices(options => { options.ConnectionString = \"localhost:6379\"; options.Serializer = SerializerType.Custom; options.CustomSerializerFactory = new CustomSerializerFactory(); }); // Option 2: Use for specific service services.AddSingleton<IRedisSerializer, ProtobufRedisSerializer>(); services.AddSingleton<IRedisCacheService>(provider => { var database = provider.GetRequiredService<IDatabase>(); var logger = provider.GetRequiredService<ILogger<RedisCacheService>>(); var options = provider.GetRequiredService<IOptions<RedisOptions>>(); var serializer = provider.GetRequiredService<ProtobufRedisSerializer>(); return new RedisCacheService(database, logger, options.Value, serializer); }); Compression Serializer Wrapper using System.IO.Compression; public class CompressedSerializer : IRedisSerializer { private readonly IRedisSerializer _innerSerializer; private readonly CompressionLevel _compressionLevel; public CompressedSerializer( IRedisSerializer innerSerializer, CompressionLevel compressionLevel = CompressionLevel.Optimal) { _innerSerializer = innerSerializer; _compressionLevel = compressionLevel; } public string Name => $\"Compressed_{_innerSerializer.Name}\"; public async Task<byte[]> SerializeAsync<T>(T value, CancellationToken cancellationToken = default) where T : class { var data = await _innerSerializer.SerializeAsync(value, cancellationToken); using var output = new MemoryStream(); using (var gzip = new GZipStream(output, _compressionLevel)) { await gzip.WriteAsync(data, 0, data.Length, cancellationToken); } return output.ToArray(); } public async Task<T?> DeserializeAsync<T>(byte[] data, CancellationToken cancellationToken = default) where T : class { using var input = new MemoryStream(data); using var gzip = new GZipStream(input, CompressionMode.Decompress); using var output = new MemoryStream(); await gzip.CopyToAsync(output, cancellationToken); var decompressed = output.ToArray(); return await _innerSerializer.DeserializeAsync<T>(decompressed, cancellationToken); } public async Task<object?> DeserializeAsync( byte[] data, Type type, CancellationToken cancellationToken = default) { using var input = new MemoryStream(data); using var gzip = new GZipStream(input, CompressionMode.Decompress); using var output = new MemoryStream(); await gzip.CopyToAsync(output, cancellationToken); var decompressed = output.ToArray(); return await _innerSerializer.DeserializeAsync(decompressed, type, cancellationToken); } } // Usage services.AddSingleton<IRedisSerializer>(provider => { var innerSerializer = RedisSerializerFactory.Create(SerializerType.MessagePack); return new CompressedSerializer(innerSerializer, CompressionLevel.Fastest); }); \uD83C\uDFD7️ Dependency Injection // In your Program.cs or Startup.cs: var builder = WebApplication.CreateBuilder(args); // Add Redis services with configuration from appsettings.json builder.Services.Configure<RedisOptions>( builder.Configuration.GetSection(\"Redis\")); builder.Services.AddRedisServices(options => { builder.Configuration.GetSection(\"Redis\").Bind(options); }); // In your services: public class UserService { private readonly IRedisCacheService _cache; private readonly IRedisPubSubService _pubSub; private readonly IRedisStreamService _stream; private readonly ILogger<UserService> _logger; public UserService( IRedisCacheService cache, IRedisPubSubService pubSub, IRedisStreamService stream, ILogger<UserService> logger) { _cache = cache; _pubSub = pubSub; _stream = stream; _logger = logger; } public async Task<User?> GetUserAsync(string userId) { // Try cache first var cached = await _cache.GetAsync<User>($\"user:{userId}\"); if (cached != null) return cached; // Load from database var user = await LoadFromDatabaseAsync(userId); // Cache for future requests if (user != null) { await _cache.SetAsync($\"user:{userId}\", user, TimeSpan.FromHours(1)); // Publish update event await _pubSub.PublishAsync(\"user-updates\", new UserLoadedEvent { UserId = userId }); } return user; } } \uD83C\uDFAF Backoff Strategies RedisKit supports multiple backoff strategies for retry operations: Fixed: Constant delay between retries Linear: Linear increase in delay Exponential: Exponential increase in delay ExponentialWithJitter: Exponential with random jitter to prevent thundering herd DecorrelatedJitter: AWS-recommended strategy with decorrelated jitter options.RetryConfiguration = new RetryConfiguration { Strategy = BackoffStrategy.DecorrelatedJitter, MaxAttempts = 5, InitialDelay = TimeSpan.FromMilliseconds(100), MaxDelay = TimeSpan.FromSeconds(10) }; \uD83D\uDE80 Performance Tips & Best Practices 1. Connection Management // ❌ DON'T: Create new connections for each operation public async Task BadExample() { var connection = await ConnectionMultiplexer.ConnectAsync(\"localhost\"); var db = connection.GetDatabase(); await db.StringSetAsync(\"key\", \"value\"); connection.Dispose(); // Connection closed! } // ✅ DO: Use dependency injection and connection pooling public class GoodExample { private readonly IRedisCacheService _cache; // Injected, pooled connection public async Task SetValueAsync() { await _cache.SetAsync(\"key\", \"value\"); } } 2. Batch Operations for Better Performance // ❌ DON'T: Multiple round trips public async Task SlowApproach(string[] userIds) { var users = new List<User>(); foreach (var id in userIds) { var user = await _cache.GetAsync<User>($\"user:{id}\"); if (user != null) users.Add(user); } } // ✅ DO: Single batch operation public async Task FastApproach(string[] userIds) { var keys = userIds.Select(id => $\"user:{id}\"); var results = await _cache.GetManyAsync<User>(keys); var users = results.Values.Where(u => u != null).ToList(); } 3. Big Key Handling // ❌ DON'T: Store huge objects as single keys public async Task BadBigKey() { var hugeList = new List<Item>(1_000_000); // 1 million items! await _cache.SetAsync(\"huge:list\", hugeList); // This blocks Redis! } // ✅ DO: Split large datasets public async Task GoodBigKeyHandling() { var items = GetLargeDataset(); var chunks = items.Chunk(1000); // Split into chunks of 1000 var tasks = chunks.Select((chunk, index) => _cache.SetAsync($\"items:chunk:{index}\", chunk.ToList(), TimeSpan.FromHours(1)) ); await Task.WhenAll(tasks); } // ✅ DO: Use Redis Streams for large datasets public async Task StreamApproach(List<Item> items) { foreach (var batch in items.Chunk(100)) { foreach (var item in batch) { await _streamService.AddAsync(\"items:stream\", item); } } } 4. Pipeline Usage // ❌ DON'T: Sequential operations public async Task SlowSequential() { await _cache.SetAsync(\"key1\", \"value1\"); await _cache.SetAsync(\"key2\", \"value2\"); await _cache.SetAsync(\"key3\", \"value3\"); // 3 round trips to Redis } // ✅ DO: Use batch/pipeline operations public async Task FastPipeline() { var items = new Dictionary<string, string> { [\"key1\"] = \"value1\", [\"key2\"] = \"value2\", [\"key3\"] = \"value3\" }; await _cache.SetManyAsync(items, TimeSpan.FromHours(1)); // Single round trip! } 5. Memory Optimization // ✅ Use appropriate serializers services.AddRedisServices(options => { // MessagePack: Fastest and smallest options.Serializer = SerializerType.MessagePack; // JSON: Human readable, larger size // options.Serializer = SerializerType.SystemTextJson; }); // ✅ Compress large objects public class CompressedCacheService { private readonly IRedisCacheService _cache; public async Task SetCompressedAsync<T>(string key, T value) where T : class { if (value is string str && str.Length > 1000) { // Compress strings larger than 1KB var compressed = Compress(str); await _cache.SetAsync($\"{key}:compressed\", compressed); } else { await _cache.SetAsync(key, value); } } } 6. Key Expiration Strategies // ✅ Use sliding expiration for frequently accessed data public async Task<T?> GetWithSlidingExpirationAsync<T>(string key) where T : class { var value = await _cache.GetAsync<T>(key); if (value != null) { // Reset expiration on each access await _cache.ExpireAsync(key, TimeSpan.FromMinutes(30)); } return value; } // ✅ Use absolute expiration for time-sensitive data public async Task SetDailyReportAsync(Report report) { var tomorrow = DateTime.UtcNow.Date.AddDays(1); var ttl = tomorrow - DateTime.UtcNow; await _cache.SetAsync($\"report:{DateTime.UtcNow:yyyy-MM-dd}\", report, ttl); } 7. Avoid Hot Keys // ❌ DON'T: Single key for global counter public async Task IncrementGlobalCounter() { var count = await _cache.GetAsync<int>(\"global:counter\"); await _cache.SetAsync(\"global:counter\", count + 1); // This key becomes a bottleneck! } // ✅ DO: Distribute load across multiple keys public async Task IncrementDistributedCounter() { var shard = Random.Shared.Next(0, 10); // 10 shards var key = $\"counter:shard:{shard}\"; var count = await _cache.GetAsync<int>(key); await _cache.SetAsync(key, count + 1); } public async Task<int> GetTotalCount() { var tasks = Enumerable.Range(0, 10) .Select(i => _cache.GetAsync<int>($\"counter:shard:{i}\")); var counts = await Task.WhenAll(tasks); return counts.Sum(); } 8. Circuit Breaker for Resilience // ✅ Configure circuit breaker to prevent cascade failures services.AddRedisServices(options => { options.CircuitBreaker = new CircuitBreakerSettings { Enabled = true, FailureThreshold = 5, // Open after 5 failures BreakDuration = TimeSpan.FromSeconds(30), // Stay open for 30s SuccessThreshold = 2 // Need 2 successes to close }; }); 9. Monitoring & Metrics // ✅ Track cache hit rates public class MetricsCacheService { private readonly IRedisCacheService _cache; private readonly IMetrics _metrics; public async Task<T?> GetWithMetricsAsync<T>(string key) where T : class { var value = await _cache.GetAsync<T>(key); if (value != null) _metrics.Increment(\"cache.hits\"); else _metrics.Increment(\"cache.misses\"); return value; } } 10. Pub/Sub Performance // ✅ Use pattern subscriptions wisely public class EfficientPubSub { private readonly IRedisPubSubService _pubSub; public async Task SubscribeEfficiently() { // Instead of subscribing to many individual channels // Use pattern subscription await _pubSub.SubscribePatternAsync<Event>( \"events:*\", // Single pattern subscription async (evt, ct) => await ProcessEventAsync(evt, ct) ); } } \uD83D\uDCCA Performance Benchmarks Serializer Performance Comparison Method JSON (ns) MessagePack (ns) Speed Improvement Memory Improvement Small Object Serialize 331.8 143.2 2.3x faster 5.6x less memory Large Object Serialize 3,569.1 1,940.7 1.8x faster Similar memory Array Serialize (100 items) 28,143.8 11,556.8 2.4x faster 3.2x less memory Small Object Deserialize 628.0 256.5 2.4x faster 2.1x less memory Async Serialize 355.9 173.8 2.0x faster 2.8x less memory Async Deserialize 823.8 290.0 2.8x faster 2.0x less memory Recommendation: Use MessagePack for production workloads requiring high performance and low memory usage. Redis Operations Performance Operation Single Item Batch (100 items) Batch (1000 items) Set ~1ms ~5ms ~40ms Get ~0.8ms ~4ms ~35ms Pub/Sub ~0.5ms N/A N/A Stream Add ~1.2ms ~8ms ~70ms Benchmarks on local Redis, actual performance depends on network latency and Redis server specs \uD83D\uDCCA Performance Considerations Connection Pooling: Connections are automatically pooled and reused Pipelining: Commands are automatically pipelined for better throughput Memory Efficiency: Uses ArrayPool and MemoryPool to minimize allocations Concurrent Operations: Thread-safe operations with minimal locking Circuit Breaker: Prevents cascading failures in distributed systems Automatic Cleanup: Inactive handlers are automatically cleaned up to prevent memory leaks \uD83E\uDDEA Testing The library includes comprehensive unit tests with 100% coverage of critical paths: dotnet test # Results Passed! - Failed: 0, Passed: 124, Skipped: 7, Total: 131 \uD83D\uDCCB Requirements .NET 9.0 or higher Redis Server 5.0 or higher (6.0+ recommended for Streams support) \uD83E\uDD1D Contributing Contributions are welcome! Please feel free to submit a Pull Request. \uD83D\uDCC4 License This project is licensed under the MIT License - see the LICENSE file for details. \uD83D\uDCDA Documentation For more detailed documentation, please visit our Wiki. \uD83D\uDC1B Known Issues Stream service tests are currently skipped as they require a real Redis instance PUBSUB NUMSUB command returns local handler count only (StackExchange.Redis limitation) \uD83D\uDEA6 Roadmap [ ] Redis Sentinel support [ ] Redis Cluster support [ ] Distributed locking primitives [ ] Geo-spatial operations [ ] Time-series data support [ ] OpenTelemetry integration [ ] Prometheus metrics export"
  },
  "api/RedisKit.Exceptions.RedisCircuitOpenException.html": {
    "href": "api/RedisKit.Exceptions.RedisCircuitOpenException.html",
    "title": "Class RedisCircuitOpenException | RedisKit",
    "summary": "Class RedisCircuitOpenException Namespace RedisKit.Exceptions Assembly RedisKit.dll Exception thrown when circuit is open public class RedisCircuitOpenException : Exception, ISerializable Inheritance object Exception RedisCircuitOpenException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors RedisCircuitOpenException() public RedisCircuitOpenException() RedisCircuitOpenException(string) public RedisCircuitOpenException(string message) Parameters message string RedisCircuitOpenException(string, Exception) public RedisCircuitOpenException(string message, Exception innerException) Parameters message string innerException Exception"
  },
  "api/RedisKit.Exceptions.html": {
    "href": "api/RedisKit.Exceptions.html",
    "title": "Namespace RedisKit.Exceptions | RedisKit",
    "summary": "Namespace RedisKit.Exceptions Classes RedisCircuitOpenException Exception thrown when circuit is open"
  },
  "api/RedisKit.Extensions.ServiceCollectionExtensions.html": {
    "href": "api/RedisKit.Extensions.ServiceCollectionExtensions.html",
    "title": "Class ServiceCollectionExtensions | RedisKit",
    "summary": "Class ServiceCollectionExtensions Namespace RedisKit.Extensions Assembly RedisKit.dll Extension methods for configuring Redis services in dependency injection container public static class ServiceCollectionExtensions Inheritance object ServiceCollectionExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddRedisServices(IServiceCollection) Adds Redis services with default configuration public static IServiceCollection AddRedisServices(this IServiceCollection services) Parameters services IServiceCollection Returns IServiceCollection AddRedisServices(IServiceCollection, Action<RedisOptions>) Adds Redis services to the dependency injection container public static IServiceCollection AddRedisServices(this IServiceCollection services, Action<RedisOptions> configureOptions) Parameters services IServiceCollection configureOptions Action<RedisOptions> Returns IServiceCollection"
  },
  "api/RedisKit.Extensions.html": {
    "href": "api/RedisKit.Extensions.html",
    "title": "Namespace RedisKit.Extensions | RedisKit",
    "summary": "Namespace RedisKit.Extensions Classes ServiceCollectionExtensions Extension methods for configuring Redis services in dependency injection container"
  },
  "api/RedisKit.Interfaces.IRedisCacheService.html": {
    "href": "api/RedisKit.Interfaces.IRedisCacheService.html",
    "title": "Interface IRedisCacheService | RedisKit",
    "summary": "Interface IRedisCacheService Namespace RedisKit.Interfaces Assembly RedisKit.dll Interface for Redis caching operations with generic support public interface IRedisCacheService Methods DeleteAsync(string, CancellationToken) Deletes an item from the cache by key Task DeleteAsync(string key, CancellationToken cancellationToken = default) Parameters key string cancellationToken CancellationToken Returns Task ExistsAsync(string, CancellationToken) Checks if a key exists in the cache Task<bool> ExistsAsync(string key, CancellationToken cancellationToken = default) Parameters key string cancellationToken CancellationToken Returns Task<bool> GetAsync<T>(string, CancellationToken) Gets an item from the cache by key Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default) where T : class Parameters key string cancellationToken CancellationToken Returns Task<T> Type Parameters T GetManyAsync<T>(IEnumerable<string>, CancellationToken) Gets multiple items from the cache Task<Dictionary<string, T?>> GetManyAsync<T>(IEnumerable<string> keys, CancellationToken cancellationToken = default) where T : class Parameters keys IEnumerable<string> cancellationToken CancellationToken Returns Task<Dictionary<string, T>> Type Parameters T SetAsync<T>(string, T, TimeSpan?, CancellationToken) Sets an item in the cache with optional TTL Task SetAsync<T>(string key, T value, TimeSpan? ttl = null, CancellationToken cancellationToken = default) where T : class Parameters key string value T ttl TimeSpan? cancellationToken CancellationToken Returns Task Type Parameters T SetKeyPrefix(string) Sets a prefix for all cache keys void SetKeyPrefix(string prefix) Parameters prefix string SetManyAsync<T>(IDictionary<string, T>, TimeSpan?, CancellationToken) Sets multiple items in the cache with optional TTL Task SetManyAsync<T>(IDictionary<string, T> values, TimeSpan? ttl = null, CancellationToken cancellationToken = default) where T : class Parameters values IDictionary<string, T> ttl TimeSpan? cancellationToken CancellationToken Returns Task Type Parameters T"
  },
  "api/RedisKit.Interfaces.IRedisPubSubService.html": {
    "href": "api/RedisKit.Interfaces.IRedisPubSubService.html",
    "title": "Interface IRedisPubSubService | RedisKit",
    "summary": "Interface IRedisPubSubService Namespace RedisKit.Interfaces Assembly RedisKit.dll Interface for Redis pub/sub operations with generic support public interface IRedisPubSubService Methods GetSubscriberCountAsync(string, CancellationToken) Gets the number of subscribers for a channel Task<int> GetSubscriberCountAsync(string channel, CancellationToken cancellationToken = default) Parameters channel string cancellationToken CancellationToken Returns Task<int> GetSubscriptionStatsAsync(CancellationToken) Gets statistics about current subscriptions Task<SubscriptionStats[]> GetSubscriptionStatsAsync(CancellationToken cancellationToken = default) Parameters cancellationToken CancellationToken Returns Task<SubscriptionStats[]> HasSubscribersAsync(string, CancellationToken) Checks if a channel has any active subscriptions Task<bool> HasSubscribersAsync(string channel, CancellationToken cancellationToken = default) Parameters channel string cancellationToken CancellationToken Returns Task<bool> PublishAsync<T>(string, T, CancellationToken) Publishes a message to a channel Task<long> PublishAsync<T>(string channel, T message, CancellationToken cancellationToken = default) where T : class Parameters channel string message T cancellationToken CancellationToken Returns Task<long> Type Parameters T SubscribeAsync<T>(string, Func<T, CancellationToken, Task>, CancellationToken) Subscribes to a channel and registers a handler for messages Task<SubscriptionToken> SubscribeAsync<T>(string channel, Func<T, CancellationToken, Task> handler, CancellationToken cancellationToken = default) where T : class Parameters channel string handler Func<T, CancellationToken, Task> cancellationToken CancellationToken Returns Task<SubscriptionToken> Subscription token that can be used to unsubscribe Type Parameters T SubscribePatternAsync<T>(string, Func<T, CancellationToken, Task>, CancellationToken) Subscribes to channels matching a pattern and registers a handler for messages Task<SubscriptionToken> SubscribePatternAsync<T>(string pattern, Func<T, CancellationToken, Task> handler, CancellationToken cancellationToken = default) where T : class Parameters pattern string handler Func<T, CancellationToken, Task> cancellationToken CancellationToken Returns Task<SubscriptionToken> Subscription token that can be used to unsubscribe Type Parameters T SubscribePatternWithChannelAsync<T>(string, Func<T, string, CancellationToken, Task>, CancellationToken) Subscribes to channels matching a pattern with channel name included Task<SubscriptionToken> SubscribePatternWithChannelAsync<T>(string pattern, Func<T, string, CancellationToken, Task> handler, CancellationToken cancellationToken = default) where T : class Parameters pattern string handler Func<T, string, CancellationToken, Task> cancellationToken CancellationToken Returns Task<SubscriptionToken> Subscription token that can be used to unsubscribe Type Parameters T SubscribeWithMetadataAsync<T>(string, Func<T, string, CancellationToken, Task>, CancellationToken) Subscribes to a channel with message metadata (channel name, publish time, etc.) Task<SubscriptionToken> SubscribeWithMetadataAsync<T>(string channel, Func<T, string, CancellationToken, Task> handler, CancellationToken cancellationToken = default) where T : class Parameters channel string handler Func<T, string, CancellationToken, Task> cancellationToken CancellationToken Returns Task<SubscriptionToken> Subscription token that can be used to unsubscribe Type Parameters T UnsubscribeAsync(SubscriptionToken, CancellationToken) Unsubscribes a specific handler from a channel Task UnsubscribeAsync(SubscriptionToken token, CancellationToken cancellationToken = default) Parameters token SubscriptionToken cancellationToken CancellationToken Returns Task UnsubscribeAsync(string, CancellationToken) Unsubscribes from a channel Task UnsubscribeAsync(string channel, CancellationToken cancellationToken = default) Parameters channel string cancellationToken CancellationToken Returns Task UnsubscribePatternAsync(string, CancellationToken) Unsubscribes from a channel pattern Task UnsubscribePatternAsync(string pattern, CancellationToken cancellationToken = default) Parameters pattern string cancellationToken CancellationToken Returns Task"
  },
  "api/RedisKit.Interfaces.IRedisStreamService.html": {
    "href": "api/RedisKit.Interfaces.IRedisStreamService.html",
    "title": "Interface IRedisStreamService | RedisKit",
    "summary": "Interface IRedisStreamService Namespace RedisKit.Interfaces Assembly RedisKit.dll Interface for Redis Streams operations with generic support public interface IRedisStreamService Methods AcknowledgeAsync(string, string, string, CancellationToken) Acknowledges a message as processed Task AcknowledgeAsync(string stream, string groupName, string messageId, CancellationToken cancellationToken = default) Parameters stream string groupName string messageId string cancellationToken CancellationToken Returns Task AddAsync<T>(string, T, int?, CancellationToken) Adds a message to a stream with optional max length for automatic trimming Task<string> AddAsync<T>(string stream, T message, int? maxLength, CancellationToken cancellationToken = default) where T : class Parameters stream string message T maxLength int? cancellationToken CancellationToken Returns Task<string> Type Parameters T AddAsync<T>(string, T, CancellationToken) Adds a message to a stream Task<string> AddAsync<T>(string stream, T message, CancellationToken cancellationToken = default) where T : class Parameters stream string message T cancellationToken CancellationToken Returns Task<string> Type Parameters T AddBatchAsync<T>(string, T[], int?, CancellationToken) Adds multiple messages to a stream in batch Task<string[]> AddBatchAsync<T>(string stream, T[] messages, int? maxLength = null, CancellationToken cancellationToken = default) where T : class Parameters stream string Stream name messages T[] Array of messages to add maxLength int? Optional max length for stream trimming cancellationToken CancellationToken Cancellation token Returns Task<string[]> Array of message IDs Type Parameters T Message type ClaimAsync<T>(string, string, string, long, string[], CancellationToken) Claims ownership of pending messages Task<Dictionary<string, T?>> ClaimAsync<T>(string stream, string groupName, string consumerName, long minIdleTime, string[] messageIds, CancellationToken cancellationToken = default) where T : class Parameters stream string The stream name groupName string Consumer group name consumerName string Consumer name claiming the messages minIdleTime long Minimum idle time in milliseconds messageIds string[] Message IDs to claim cancellationToken CancellationToken Cancellation token Returns Task<Dictionary<string, T>> Dictionary of claimed messages Type Parameters T CreateConsumerGroupAsync(string, string, CancellationToken) Creates a consumer group for a stream Task CreateConsumerGroupAsync(string stream, string groupName, CancellationToken cancellationToken = default) Parameters stream string groupName string cancellationToken CancellationToken Returns Task DeleteAsync(string, string[], CancellationToken) Deletes messages from a stream Task<long> DeleteAsync(string stream, string[] messageIds, CancellationToken cancellationToken = default) Parameters stream string The stream name messageIds string[] Array of message IDs to delete cancellationToken CancellationToken Cancellation token Returns Task<long> Number of messages deleted GetHealthAsync(string, bool, CancellationToken) Gets health information about a stream Task<StreamHealthInfo> GetHealthAsync(string stream, bool includeGroups = true, CancellationToken cancellationToken = default) Parameters stream string Stream name includeGroups bool Include consumer group information cancellationToken CancellationToken Cancellation token Returns Task<StreamHealthInfo> Stream health information GetInfoAsync(string, CancellationToken) Gets information about a stream Task<StreamInfo> GetInfoAsync(string stream, CancellationToken cancellationToken = default) Parameters stream string The stream name cancellationToken CancellationToken Cancellation token Returns Task<StreamInfo> Stream information including length, first and last entry IDs, consumer groups GetMetricsAsync(string, string?, TimeSpan?, CancellationToken) Collects metrics about stream operations Task<StreamMetrics> GetMetricsAsync(string stream, string? groupName = null, TimeSpan? window = null, CancellationToken cancellationToken = default) Parameters stream string Stream name groupName string Optional consumer group name for group-specific metrics window TimeSpan? Time window for rate calculations cancellationToken CancellationToken Cancellation token Returns Task<StreamMetrics> Stream metrics GetPendingAsync(string, string, int, string?, CancellationToken) Gets pending messages for a consumer group Task<StreamPendingMessageInfo[]> GetPendingAsync(string stream, string groupName, int count = 10, string? consumerName = null, CancellationToken cancellationToken = default) Parameters stream string The stream name groupName string Consumer group name count int Maximum number of pending messages to return consumerName string Optional consumer name to filter by cancellationToken CancellationToken Cancellation token Returns Task<StreamPendingMessageInfo[]> List of pending message information MoveToDeadLetterAsync<T>(string, string, string, string, int, string?, string?, CancellationToken) Moves a failed message to dead letter queue Task<string> MoveToDeadLetterAsync<T>(string sourceStream, string deadLetterStream, string messageId, string reason, int retryCount = 0, string? groupName = null, string? consumerName = null, CancellationToken cancellationToken = default) where T : class Parameters sourceStream string Source stream name deadLetterStream string Dead letter queue stream name messageId string Message ID to move reason string Reason for moving to DLQ retryCount int Number of retries attempted groupName string Consumer group name consumerName string Consumer name cancellationToken CancellationToken Cancellation token Returns Task<string> Dead letter queue message ID Type Parameters T Message type ReadAsync<T>(string, string?, string?, int, CancellationToken) Reads messages from a stream Task<Dictionary<string, T?>> ReadAsync<T>(string stream, string? start = null, string? end = null, int count = 10, CancellationToken cancellationToken = default) where T : class Parameters stream string start string end string count int cancellationToken CancellationToken Returns Task<Dictionary<string, T>> Type Parameters T ReadGroupAsync<T>(string, string, string, int, CancellationToken) Reads messages from a stream using consumer group Task<Dictionary<string, T?>> ReadGroupAsync<T>(string stream, string groupName, string consumerName, int count = 10, CancellationToken cancellationToken = default) where T : class Parameters stream string groupName string consumerName string count int cancellationToken CancellationToken Returns Task<Dictionary<string, T>> Type Parameters T ReadGroupWithAutoAckAsync<T>(string, string, string, Func<T, Task<bool>>, int, CancellationToken) Reads from consumer group with automatic acknowledgment on successful processing Task<int> ReadGroupWithAutoAckAsync<T>(string stream, string groupName, string consumerName, Func<T, Task<bool>> processor, int count = 10, CancellationToken cancellationToken = default) where T : class Parameters stream string Stream name groupName string Consumer group name consumerName string Consumer name processor Func<T, Task<bool>> Message processor function that returns success/failure count int Number of messages to read cancellationToken CancellationToken Cancellation token Returns Task<int> Number of successfully processed messages Type Parameters T Message type RetryPendingAsync<T>(string, string, string, Func<T, Task<bool>>, RetryConfiguration?, CancellationToken) Retries pending messages that have timed out Task<RetryResult<T>> RetryPendingAsync<T>(string stream, string groupName, string consumerName, Func<T, Task<bool>> processor, RetryConfiguration? retryConfig = null, CancellationToken cancellationToken = default) where T : class Parameters stream string Stream name groupName string Consumer group name consumerName string Consumer name processor Func<T, Task<bool>> Message processor function retryConfig RetryConfiguration Retry configuration cancellationToken CancellationToken Cancellation token Returns Task<RetryResult<T>> Retry operation result Type Parameters T Message type TrimByLengthAsync(string, int, bool, CancellationToken) Trims the stream to a specified maximum length Task<long> TrimByLengthAsync(string stream, int maxLength, bool useApproximateMaxLength = true, CancellationToken cancellationToken = default) Parameters stream string The stream name maxLength int Maximum number of entries to keep useApproximateMaxLength bool Use approximate trimming for better performance cancellationToken CancellationToken Cancellation token Returns Task<long> Number of messages trimmed"
  },
  "api/RedisKit.Interfaces.html": {
    "href": "api/RedisKit.Interfaces.html",
    "title": "Namespace RedisKit.Interfaces | RedisKit",
    "summary": "Namespace RedisKit.Interfaces Interfaces IRedisCacheService Interface for Redis caching operations with generic support IRedisPubSubService Interface for Redis pub/sub operations with generic support IRedisStreamService Interface for Redis Streams operations with generic support"
  },
  "api/RedisKit.Models.BackoffStrategy.html": {
    "href": "api/RedisKit.Models.BackoffStrategy.html",
    "title": "Enum BackoffStrategy | RedisKit",
    "summary": "Enum BackoffStrategy Namespace RedisKit.Models Assembly RedisKit.dll Backoff strategy for retry logic public enum BackoffStrategy Fields DecorrelatedJitter = 4 Decorrelated jitter backoff (AWS recommended) Exponential = 2 Exponential increase in delay ExponentialWithJitter = 3 Exponential with random jitter to prevent thundering herd Fixed = 0 Fixed delay between retries Linear = 1 Linear increase in delay"
  },
  "api/RedisKit.Models.CircuitBreakerSettings.html": {
    "href": "api/RedisKit.Models.CircuitBreakerSettings.html",
    "title": "Class CircuitBreakerSettings | RedisKit",
    "summary": "Class CircuitBreakerSettings Namespace RedisKit.Models Assembly RedisKit.dll Circuit breaker configuration public class CircuitBreakerSettings Inheritance object CircuitBreakerSettings Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties BreakDuration Duration to keep circuit open public TimeSpan BreakDuration { get; set; } Property Value TimeSpan Enabled Enable circuit breaker pattern public bool Enabled { get; set; } Property Value bool FailureThreshold Number of failures before opening circuit public int FailureThreshold { get; set; } Property Value int FailureWindow Time window for counting failures public TimeSpan FailureWindow { get; set; } Property Value TimeSpan SuccessThreshold Number of successful calls to close circuit public int SuccessThreshold { get; set; } Property Value int"
  },
  "api/RedisKit.Models.CircuitState.html": {
    "href": "api/RedisKit.Models.CircuitState.html",
    "title": "Enum CircuitState | RedisKit",
    "summary": "Enum CircuitState Namespace RedisKit.Models Assembly RedisKit.dll Connection state for circuit breaker public enum CircuitState Fields Closed = 0 Circuit is closed, normal operation HalfOpen = 2 Circuit is half-open, testing if service recovered Open = 1 Circuit is open, rejecting requests"
  },
  "api/RedisKit.Models.ConnectionHealthStatus.html": {
    "href": "api/RedisKit.Models.ConnectionHealthStatus.html",
    "title": "Class ConnectionHealthStatus | RedisKit",
    "summary": "Class ConnectionHealthStatus Namespace RedisKit.Models Assembly RedisKit.dll Connection health status public class ConnectionHealthStatus Inheritance object ConnectionHealthStatus Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CircuitState public CircuitState CircuitState { get; set; } Property Value CircuitState ConsecutiveFailures public int ConsecutiveFailures { get; set; } Property Value int FailedRequests public long FailedRequests { get; set; } Property Value long IsHealthy public bool IsHealthy { get; set; } Property Value bool LastCheckTime public DateTime LastCheckTime { get; set; } Property Value DateTime LastError public string? LastError { get; set; } Property Value string ResponseTime public TimeSpan ResponseTime { get; set; } Property Value TimeSpan SuccessRate public double SuccessRate { get; } Property Value double TotalRequests public long TotalRequests { get; set; } Property Value long"
  },
  "api/RedisKit.Models.ConnectionTimeoutSettings.html": {
    "href": "api/RedisKit.Models.ConnectionTimeoutSettings.html",
    "title": "Class ConnectionTimeoutSettings | RedisKit",
    "summary": "Class ConnectionTimeoutSettings Namespace RedisKit.Models Assembly RedisKit.dll Connection timeout configuration for Redis operations public class ConnectionTimeoutSettings Inheritance object ConnectionTimeoutSettings Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties AsyncTimeout Timeout for asynchronous operations public TimeSpan AsyncTimeout { get; set; } Property Value TimeSpan ConfigCheckSeconds Timeout for configuration retrieval public TimeSpan ConfigCheckSeconds { get; set; } Property Value TimeSpan ConnectTimeout Timeout for initial connection establishment public TimeSpan ConnectTimeout { get; set; } Property Value TimeSpan KeepAlive Keep-alive interval for connection health checks public TimeSpan KeepAlive { get; set; } Property Value TimeSpan ResponseTimeout Response timeout for operations (DEPRECATED) [Obsolete(\"ResponseTimeout is obsolete in StackExchange.Redis 2.7+ and has no effect. Use SyncTimeout and AsyncTimeout instead.\")] public TimeSpan ResponseTimeout { get; set; } Property Value TimeSpan Remarks This property is deprecated in StackExchange.Redis 2.7+ and has no effect. It will be removed in a future version to align with StackExchange.Redis 3.0. Use SyncTimeout and AsyncTimeout instead for controlling operation timeouts. SyncTimeout Timeout for synchronous operations public TimeSpan SyncTimeout { get; set; } Property Value TimeSpan"
  },
  "api/RedisKit.Models.DeadLetterMessage-1.html": {
    "href": "api/RedisKit.Models.DeadLetterMessage-1.html",
    "title": "Class DeadLetterMessage<T> | RedisKit",
    "summary": "Class DeadLetterMessage<T> Namespace RedisKit.Models Assembly RedisKit.dll Represents a message that failed processing and was moved to dead letter queue public class DeadLetterMessage<T> where T : class Type Parameters T Inheritance object DeadLetterMessage<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ConsumerName Consumer that was processing the message public string? ConsumerName { get; set; } Property Value string ExceptionDetails Exception details if available public string? ExceptionDetails { get; set; } Property Value string FailedAt When the failure occurred public DateTime FailedAt { get; set; } Property Value DateTime FailureReason Reason for failure public string FailureReason { get; set; } Property Value string GroupName Consumer group that owned the message public string? GroupName { get; set; } Property Value string OriginalMessage The original message that failed public T? OriginalMessage { get; set; } Property Value T OriginalMessageId Original message ID in the stream public string OriginalMessageId { get; set; } Property Value string OriginalStream Original stream name public string OriginalStream { get; set; } Property Value string RetryCount Number of retry attempts before moving to DLQ public int RetryCount { get; set; } Property Value int"
  },
  "api/RedisKit.Models.HealthMonitoringSettings.html": {
    "href": "api/RedisKit.Models.HealthMonitoringSettings.html",
    "title": "Class HealthMonitoringSettings | RedisKit",
    "summary": "Class HealthMonitoringSettings Namespace RedisKit.Models Assembly RedisKit.dll Connection health monitoring settings public class HealthMonitoringSettings Inheritance object HealthMonitoringSettings Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties AutoReconnect Enable automatic reconnection on health failure public bool AutoReconnect { get; set; } Property Value bool CheckInterval Interval for health checks public TimeSpan CheckInterval { get; set; } Property Value TimeSpan CheckTimeout Timeout for health check operations public TimeSpan CheckTimeout { get; set; } Property Value TimeSpan ConsecutiveFailuresThreshold Number of consecutive failures before marking unhealthy public int ConsecutiveFailuresThreshold { get; set; } Property Value int Enabled Enable health monitoring public bool Enabled { get; set; } Property Value bool"
  },
  "api/RedisKit.Models.RedisOptions.html": {
    "href": "api/RedisKit.Models.RedisOptions.html",
    "title": "Class RedisOptions | RedisKit",
    "summary": "Class RedisOptions Namespace RedisKit.Models Assembly RedisKit.dll Configuration options for Redis connection and operations public class RedisOptions Inheritance object RedisOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CacheKeyPrefix Prefix for all cache keys public string CacheKeyPrefix { get; set; } Property Value string CircuitBreaker Circuit breaker settings public CircuitBreakerSettings CircuitBreaker { get; set; } Property Value CircuitBreakerSettings ConnectionString Connection string for Redis server public string ConnectionString { get; set; } Property Value string DefaultTtl Default TTL for cache entries (if not specified) public TimeSpan DefaultTtl { get; set; } Property Value TimeSpan HealthMonitoring Health monitoring settings public HealthMonitoringSettings HealthMonitoring { get; set; } Property Value HealthMonitoringSettings JsonOptions JSON serializer options (used when Serializer is SystemTextJson) public JsonSerializerOptions? JsonOptions { get; set; } Property Value JsonSerializerOptions MessagePackOptions MessagePack serializer options (used when Serializer is MessagePack) public MessagePackSerializerOptions? MessagePackOptions { get; set; } Property Value MessagePackSerializerOptions OperationTimeout Timeout for Redis operations public TimeSpan OperationTimeout { get; set; } Property Value TimeSpan RetryAttempts Number of retry attempts for failed operations public int RetryAttempts { get; set; } Property Value int RetryConfiguration Retry configuration with backoff strategies public RetryConfiguration RetryConfiguration { get; set; } Property Value RetryConfiguration RetryDelay Delay between retry attempts public TimeSpan RetryDelay { get; set; } Property Value TimeSpan Serializer Serializer type to use for serialization public SerializerType Serializer { get; set; } Property Value SerializerType TimeoutSettings Advanced connection timeout settings public ConnectionTimeoutSettings TimeoutSettings { get; set; } Property Value ConnectionTimeoutSettings"
  },
  "api/RedisKit.Models.RetryConfiguration.html": {
    "href": "api/RedisKit.Models.RetryConfiguration.html",
    "title": "Class RetryConfiguration | RedisKit",
    "summary": "Class RetryConfiguration Namespace RedisKit.Models Assembly RedisKit.dll Retry configuration with advanced backoff strategies public class RetryConfiguration Inheritance object RetryConfiguration Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties BackoffMultiplier Multiplier for exponential backoff public double BackoffMultiplier { get; set; } Property Value double DeadLetterSuffix Dead letter queue suffix (Stream-specific) public string DeadLetterSuffix { get; set; } Property Value string IdleTimeout Idle timeout for pending messages (Stream-specific) public TimeSpan IdleTimeout { get; set; } Property Value TimeSpan InitialDelay Initial delay between retries public TimeSpan InitialDelay { get; set; } Property Value TimeSpan JitterFactor Maximum jitter percentage (0.0 to 1.0) public double JitterFactor { get; set; } Property Value double MaxAttempts Maximum number of retry attempts public int MaxAttempts { get; set; } Property Value int MaxDelay Maximum delay between retries public TimeSpan MaxDelay { get; set; } Property Value TimeSpan MaxRetries Alias for MaxAttempts (for backward compatibility) public int MaxRetries { get; set; } Property Value int MoveToDeadLetterQueue Move to dead letter queue after max retries (Stream-specific) public bool MoveToDeadLetterQueue { get; set; } Property Value bool RetryDelay Alias for InitialDelay (for backward compatibility) public TimeSpan RetryDelay { get; set; } Property Value TimeSpan Strategy Backoff strategy to use public BackoffStrategy Strategy { get; set; } Property Value BackoffStrategy UseExponentialBackoff Use exponential backoff for retries (Stream-specific) public bool UseExponentialBackoff { get; set; } Property Value bool"
  },
  "api/RedisKit.Models.RetryResult-1.html": {
    "href": "api/RedisKit.Models.RetryResult-1.html",
    "title": "Class RetryResult<T> | RedisKit",
    "summary": "Class RetryResult<T> Namespace RedisKit.Models Assembly RedisKit.dll Result of a retry operation public class RetryResult<T> where T : class Type Parameters T Inheritance object RetryResult<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties DeadLetterCount Number of messages moved to the dead letter queue public int DeadLetterCount { get; set; } Property Value int ElapsedTime Total time taken for retry operation public TimeSpan ElapsedTime { get; set; } Property Value TimeSpan FailedMessages Failed messages with error details public Dictionary<string, string> FailedMessages { get; set; } Property Value Dictionary<string, string> FailureCount Number of messages that failed public int FailureCount { get; set; } Property Value int ProcessedMessages Successfully processed messages public Dictionary<string, T> ProcessedMessages { get; set; } Property Value Dictionary<string, T> SuccessCount Number of messages successfully processed public int SuccessCount { get; set; } Property Value int"
  },
  "api/RedisKit.Models.SerializerType.html": {
    "href": "api/RedisKit.Models.SerializerType.html",
    "title": "Enum SerializerType | RedisKit",
    "summary": "Enum SerializerType Namespace RedisKit.Models Assembly RedisKit.dll Available serializer types public enum SerializerType Fields Custom = 2 MessagePack = 0 SystemTextJson = 1"
  },
  "api/RedisKit.Models.StreamHealthInfo.html": {
    "href": "api/RedisKit.Models.StreamHealthInfo.html",
    "title": "Class StreamHealthInfo | RedisKit",
    "summary": "Class StreamHealthInfo Namespace RedisKit.Models Assembly RedisKit.dll Contains health information about a Redis Stream public class StreamHealthInfo Inheritance object StreamHealthInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CheckedAt Timestamp of the health check public DateTime CheckedAt { get; set; } Property Value DateTime ConsumerGroupCount Number of consumer groups public int ConsumerGroupCount { get; set; } Property Value int HealthMessage Health check message public string HealthMessage { get; set; } Property Value string IsHealthy Indicates if the stream is healthy based on thresholds public bool IsHealthy { get; set; } Property Value bool Length Total number of messages in the stream public long Length { get; set; } Property Value long OldestPendingAge Age of the oldest pending message public TimeSpan OldestPendingAge { get; set; } Property Value TimeSpan TotalPendingMessages Total number of pending messages across all consumer groups public long TotalPendingMessages { get; set; } Property Value long"
  },
  "api/RedisKit.Models.StreamMetrics.html": {
    "href": "api/RedisKit.Models.StreamMetrics.html",
    "title": "Class StreamMetrics | RedisKit",
    "summary": "Class StreamMetrics Namespace RedisKit.Models Assembly RedisKit.dll Contains metrics about stream operations public class StreamMetrics Inheritance object StreamMetrics Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties AverageProcessingTime Average time messages spend in pending state public TimeSpan AverageProcessingTime { get; set; } Property Value TimeSpan CollectedAt Timestamp of the metrics collection public DateTime CollectedAt { get; set; } Property Value DateTime DeadLetterCount Number of messages in the dead letter queue public long DeadLetterCount { get; set; } Property Value long MeasurementWindow Time window used for rate calculations public TimeSpan MeasurementWindow { get; set; } Property Value TimeSpan MessagesPerSecond Messages processed per second (calculated over a time window) public double MessagesPerSecond { get; set; } Property Value double PendingMessages Number of pending messages public long PendingMessages { get; set; } Property Value long TotalConsumers Number of consumers in all groups public int TotalConsumers { get; set; } Property Value int TotalMessages Total number of messages in the stream public long TotalMessages { get; set; } Property Value long"
  },
  "api/RedisKit.Models.SubscriptionStats.html": {
    "href": "api/RedisKit.Models.SubscriptionStats.html",
    "title": "Class SubscriptionStats | RedisKit",
    "summary": "Class SubscriptionStats Namespace RedisKit.Models Assembly RedisKit.dll Subscription statistics public class SubscriptionStats Inheritance object SubscriptionStats Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties AverageProcessingTime public TimeSpan AverageProcessingTime { get; set; } Property Value TimeSpan ChannelOrPattern public string ChannelOrPattern { get; set; } Property Value string HandlerCount public int HandlerCount { get; set; } Property Value int LastMessageAt public DateTime? LastMessageAt { get; set; } Property Value DateTime? MessagesFailed public long MessagesFailed { get; set; } Property Value long MessagesProcessed public long MessagesProcessed { get; set; } Property Value long MessagesReceived public long MessagesReceived { get; set; } Property Value long Type public SubscriptionType Type { get; set; } Property Value SubscriptionType Methods IncrementMessagesFailed() public void IncrementMessagesFailed() IncrementMessagesProcessed() public void IncrementMessagesProcessed() IncrementMessagesReceived() public void IncrementMessagesReceived()"
  },
  "api/RedisKit.Models.SubscriptionToken.html": {
    "href": "api/RedisKit.Models.SubscriptionToken.html",
    "title": "Class SubscriptionToken | RedisKit",
    "summary": "Class SubscriptionToken Namespace RedisKit.Models Assembly RedisKit.dll Represents a subscription to a Redis channel or pattern public class SubscriptionToken : IDisposable Inheritance object SubscriptionToken Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors SubscriptionToken(string, string, SubscriptionType, Func<Task>?) public SubscriptionToken(string id, string channelOrPattern, SubscriptionType type, Func<Task>? disposeAction = null) Parameters id string channelOrPattern string type SubscriptionType disposeAction Func<Task> Properties ChannelOrPattern public string ChannelOrPattern { get; } Property Value string Id public string Id { get; } Property Value string Type public SubscriptionType Type { get; } Property Value SubscriptionType Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() UnsubscribeAsync() public Task UnsubscribeAsync() Returns Task"
  },
  "api/RedisKit.Models.SubscriptionType.html": {
    "href": "api/RedisKit.Models.SubscriptionType.html",
    "title": "Enum SubscriptionType | RedisKit",
    "summary": "Enum SubscriptionType Namespace RedisKit.Models Assembly RedisKit.dll Type of subscription public enum SubscriptionType Fields Channel = 0 Pattern = 1"
  },
  "api/RedisKit.Models.html": {
    "href": "api/RedisKit.Models.html",
    "title": "Namespace RedisKit.Models | RedisKit",
    "summary": "Namespace RedisKit.Models Classes CircuitBreakerSettings Circuit breaker configuration ConnectionHealthStatus Connection health status ConnectionTimeoutSettings Connection timeout configuration for Redis operations DeadLetterMessage<T> Represents a message that failed processing and was moved to dead letter queue HealthMonitoringSettings Connection health monitoring settings RedisOptions Configuration options for Redis connection and operations RetryConfiguration Retry configuration with advanced backoff strategies RetryResult<T> Result of a retry operation StreamHealthInfo Contains health information about a Redis Stream StreamMetrics Contains metrics about stream operations SubscriptionStats Subscription statistics SubscriptionToken Represents a subscription to a Redis channel or pattern Enums BackoffStrategy Backoff strategy for retry logic CircuitState Connection state for circuit breaker SerializerType Available serializer types SubscriptionType Type of subscription"
  },
  "api/RedisKit.Serialization.IRedisSerializer.html": {
    "href": "api/RedisKit.Serialization.IRedisSerializer.html",
    "title": "Interface IRedisSerializer | RedisKit",
    "summary": "Interface IRedisSerializer Namespace RedisKit.Serialization Assembly RedisKit.dll Interface for Redis serialization operations supporting both sync and async methods public interface IRedisSerializer Properties Name Gets the name of the serializer (e.g., \"MessagePack\", \"SystemTextJson\") string Name { get; } Property Value string Methods DeserializeAsync(byte[], Type, CancellationToken) Deserializes a byte array to an object using runtime type (asynchronous) Task<object?> DeserializeAsync(byte[] data, Type type, CancellationToken cancellationToken = default) Parameters data byte[] Byte array data to deserialize type Type Target type for deserialization cancellationToken CancellationToken Cancellation token Returns Task<object> Task representing the deserialized object or null if deserialization fails DeserializeAsync<T>(byte[], CancellationToken) Deserializes a byte array to an object (asynchronous) Task<T?> DeserializeAsync<T>(byte[] data, CancellationToken cancellationToken = default) Parameters data byte[] Byte array data to deserialize cancellationToken CancellationToken Cancellation token Returns Task<T> Task representing the deserialized object or null if deserialization fails Type Parameters T Type of object to deserialize Deserialize<T>(byte[]) Deserializes a byte array to an object (synchronous) T? Deserialize<T>(byte[] data) Parameters data byte[] Byte array data to deserialize Returns T Deserialized object or null if deserialization fails Type Parameters T Type of object to deserialize SerializeAsync<T>(T, CancellationToken) Serializes an object to byte array (asynchronous) Task<byte[]> SerializeAsync<T>(T obj, CancellationToken cancellationToken = default) Parameters obj T Object to serialize cancellationToken CancellationToken Cancellation token Returns Task<byte[]> Task representing the serialized byte array Type Parameters T Type of object to serialize Serialize<T>(T) Serializes an object to byte array (synchronous) byte[] Serialize<T>(T obj) Parameters obj T Object to serialize Returns byte[] Serialized byte array Type Parameters T Type of object to serialize"
  },
  "api/RedisKit.Serialization.RedisSerializerFactory.html": {
    "href": "api/RedisKit.Serialization.RedisSerializerFactory.html",
    "title": "Class RedisSerializerFactory | RedisKit",
    "summary": "Class RedisSerializerFactory Namespace RedisKit.Serialization Assembly RedisKit.dll Factory for creating Redis serializers with support for custom serializers and thread-safe singleton instances public static class RedisSerializerFactory Inheritance object RedisSerializerFactory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CacheSize Gets the number of cached serializers public static int CacheSize { get; } Property Value int CustomSerializerCount Gets the number of registered custom serializers public static int CustomSerializerCount { get; } Property Value int Methods ClearCache() Clears the serializer cache (useful for testing) public static void ClearCache() Create(SerializerType, ILoggerFactory?) Creates a serializer instance based on the specified type public static IRedisSerializer Create(SerializerType serializerType, ILoggerFactory? loggerFactory = null) Parameters serializerType SerializerType The type of serializer to create loggerFactory ILoggerFactory Optional logger factory for logging Returns IRedisSerializer An instance of IRedisSerializer CreateCustom(Type, ILoggerFactory?) Creates a custom serializer instance public static IRedisSerializer CreateCustom(Type serializerType, ILoggerFactory? loggerFactory = null) Parameters serializerType Type The type of the custom serializer loggerFactory ILoggerFactory Optional logger factory for logging Returns IRedisSerializer An instance of IRedisSerializer CreateCustom(Type, object, ILoggerFactory?) Creates a custom serializer instance with specific options public static IRedisSerializer CreateCustom(Type serializerType, object options, ILoggerFactory? loggerFactory = null) Parameters serializerType Type The type of the custom serializer options object Options for the serializer loggerFactory ILoggerFactory Optional logger factory for logging Returns IRedisSerializer An instance of IRedisSerializer CreateWithOptions(SerializerType, object?, ILoggerFactory?) Alternative method using if-else pattern matching for better readability in some cases public static IRedisSerializer CreateWithOptions(SerializerType serializerType, object? options = null, ILoggerFactory? loggerFactory = null) Parameters serializerType SerializerType options object loggerFactory ILoggerFactory Returns IRedisSerializer Create<TOptions>(SerializerType, TOptions, ILoggerFactory?) Creates a serializer instance with custom options using pattern matching public static IRedisSerializer Create<TOptions>(SerializerType serializerType, TOptions options, ILoggerFactory? loggerFactory = null) where TOptions : class Parameters serializerType SerializerType The type of serializer to create options TOptions Serializer-specific options loggerFactory ILoggerFactory Optional logger factory for logging Returns IRedisSerializer An instance of IRedisSerializer Type Parameters TOptions RegisterCustomSerializer(Type) Registers a custom serializer type with improved pattern matching public static void RegisterCustomSerializer(Type serializerType) Parameters serializerType Type The type of the custom serializer RegisterCustomSerializer<TSerializer>(TSerializer) Registers a custom serializer instance directly public static void RegisterCustomSerializer<TSerializer>(TSerializer serializer) where TSerializer : IRedisSerializer Parameters serializer TSerializer The serializer instance Type Parameters TSerializer The type of the serializer TryGetCustomSerializer<TSerializer>(out TSerializer?) Tries to get a registered custom serializer public static bool TryGetCustomSerializer<TSerializer>(out TSerializer? serializer) where TSerializer : IRedisSerializer Parameters serializer TSerializer The serializer instance if found Returns bool True if the serializer was found, false otherwise Type Parameters TSerializer The type of the serializer"
  },
  "api/RedisKit.Serialization.html": {
    "href": "api/RedisKit.Serialization.html",
    "title": "Namespace RedisKit.Serialization | RedisKit",
    "summary": "Namespace RedisKit.Serialization Classes RedisSerializerFactory Factory for creating Redis serializers with support for custom serializers and thread-safe singleton instances Interfaces IRedisSerializer Interface for Redis serialization operations supporting both sync and async methods"
  },
  "api/RedisKit.Services.PubSubService.html": {
    "href": "api/RedisKit.Services.PubSubService.html",
    "title": "Class PubSubService | RedisKit",
    "summary": "Class PubSubService Namespace RedisKit.Services Assembly RedisKit.dll High-performance implementation of IRedisPubSubService with advanced features public class PubSubService : IRedisPubSubService, IDisposable Inheritance object PubSubService Implements IRedisPubSubService IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PubSubService(ISubscriber, ILogger<PubSubService>, RedisOptions) public PubSubService(ISubscriber subscriber, ILogger<PubSubService> logger, RedisOptions options) Parameters subscriber ISubscriber logger ILogger<PubSubService> options RedisOptions Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() Dispose(bool) protected virtual void Dispose(bool disposing) Parameters disposing bool GetStatistics() public IReadOnlyDictionary<string, SubscriptionStats> GetStatistics() Returns IReadOnlyDictionary<string, SubscriptionStats> GetStatistics(string) public SubscriptionStats? GetStatistics(string channelOrPattern) Parameters channelOrPattern string Returns SubscriptionStats GetSubscriberCountAsync(string, CancellationToken) Gets the number of subscribers for a channel public Task<int> GetSubscriberCountAsync(string channel, CancellationToken cancellationToken = default) Parameters channel string cancellationToken CancellationToken Returns Task<int> GetSubscriptionStatsAsync(CancellationToken) Gets statistics about current subscriptions public Task<SubscriptionStats[]> GetSubscriptionStatsAsync(CancellationToken cancellationToken = default) Parameters cancellationToken CancellationToken Returns Task<SubscriptionStats[]> HasSubscribersAsync(string, CancellationToken) Checks if a channel has any active subscriptions public Task<bool> HasSubscribersAsync(string channel, CancellationToken cancellationToken = default) Parameters channel string cancellationToken CancellationToken Returns Task<bool> PublishAsync<T>(string, T, CancellationToken) Publishes a message to a channel public Task<long> PublishAsync<T>(string channel, T message, CancellationToken cancellationToken = default) where T : class Parameters channel string message T cancellationToken CancellationToken Returns Task<long> Type Parameters T SubscribeAsync<T>(string, Func<T, CancellationToken, Task>, CancellationToken) Subscribes to a channel and registers a handler for messages public Task<SubscriptionToken> SubscribeAsync<T>(string channel, Func<T, CancellationToken, Task> handler, CancellationToken cancellationToken = default) where T : class Parameters channel string handler Func<T, CancellationToken, Task> cancellationToken CancellationToken Returns Task<SubscriptionToken> Subscription token that can be used to unsubscribe Type Parameters T SubscribePatternAsync<T>(string, Func<T, CancellationToken, Task>, CancellationToken) Subscribes to channels matching a pattern and registers a handler for messages public Task<SubscriptionToken> SubscribePatternAsync<T>(string pattern, Func<T, CancellationToken, Task> handler, CancellationToken cancellationToken = default) where T : class Parameters pattern string handler Func<T, CancellationToken, Task> cancellationToken CancellationToken Returns Task<SubscriptionToken> Subscription token that can be used to unsubscribe Type Parameters T SubscribePatternWithChannelAsync<T>(string, Func<T, string, CancellationToken, Task>, CancellationToken) Subscribes to channels matching a pattern with channel name included public Task<SubscriptionToken> SubscribePatternWithChannelAsync<T>(string pattern, Func<T, string, CancellationToken, Task> handler, CancellationToken cancellationToken = default) where T : class Parameters pattern string handler Func<T, string, CancellationToken, Task> cancellationToken CancellationToken Returns Task<SubscriptionToken> Subscription token that can be used to unsubscribe Type Parameters T SubscribePatternWithMetadataAsync<T>(string, Func<T, string, CancellationToken, Task>, CancellationToken) public Task<SubscriptionToken> SubscribePatternWithMetadataAsync<T>(string pattern, Func<T, string, CancellationToken, Task> handler, CancellationToken cancellationToken = default) where T : class Parameters pattern string handler Func<T, string, CancellationToken, Task> cancellationToken CancellationToken Returns Task<SubscriptionToken> Type Parameters T SubscribeWithMetadataAsync<T>(string, Func<T, string, CancellationToken, Task>, CancellationToken) Subscribes to a channel with message metadata (channel name, publish time, etc.) public Task<SubscriptionToken> SubscribeWithMetadataAsync<T>(string channel, Func<T, string, CancellationToken, Task> handler, CancellationToken cancellationToken = default) where T : class Parameters channel string handler Func<T, string, CancellationToken, Task> cancellationToken CancellationToken Returns Task<SubscriptionToken> Subscription token that can be used to unsubscribe Type Parameters T UnsubscribeAllAsync(CancellationToken) public Task UnsubscribeAllAsync(CancellationToken cancellationToken = default) Parameters cancellationToken CancellationToken Returns Task UnsubscribeAsync(SubscriptionToken, CancellationToken) Unsubscribes a specific handler from a channel public Task UnsubscribeAsync(SubscriptionToken token, CancellationToken cancellationToken = default) Parameters token SubscriptionToken cancellationToken CancellationToken Returns Task UnsubscribeAsync(string, CancellationToken) Unsubscribes from a channel public Task UnsubscribeAsync(string channel, CancellationToken cancellationToken = default) Parameters channel string cancellationToken CancellationToken Returns Task UnsubscribePatternAsync(string, CancellationToken) Unsubscribes from a channel pattern public Task UnsubscribePatternAsync(string pattern, CancellationToken cancellationToken = default) Parameters pattern string cancellationToken CancellationToken Returns Task"
  },
  "api/RedisKit.Services.RedisCacheService.html": {
    "href": "api/RedisKit.Services.RedisCacheService.html",
    "title": "Class RedisCacheService | RedisKit",
    "summary": "Class RedisCacheService Namespace RedisKit.Services Assembly RedisKit.dll Implementation of IRedisCacheService using StackExchange.Redis and configurable serialization public class RedisCacheService : IRedisCacheService Inheritance object RedisCacheService Implements IRedisCacheService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RedisCacheService(IDatabaseAsync, ILogger<RedisCacheService>, RedisOptions) public RedisCacheService(IDatabaseAsync database, ILogger<RedisCacheService> logger, RedisOptions options) Parameters database IDatabaseAsync logger ILogger<RedisCacheService> options RedisOptions Methods DeleteAsync(string, CancellationToken) Deletes an item from the cache by key public Task DeleteAsync(string key, CancellationToken cancellationToken = default) Parameters key string cancellationToken CancellationToken Returns Task ExistsAsync(string, CancellationToken) Checks if a key exists in the cache public Task<bool> ExistsAsync(string key, CancellationToken cancellationToken = default) Parameters key string cancellationToken CancellationToken Returns Task<bool> GetAsync<T>(string, CancellationToken) Gets an item from the cache by key public Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default) where T : class Parameters key string cancellationToken CancellationToken Returns Task<T> Type Parameters T GetManyAsync<T>(IEnumerable<string>, CancellationToken) Gets multiple items from the cache public Task<Dictionary<string, T?>> GetManyAsync<T>(IEnumerable<string> keys, CancellationToken cancellationToken = default) where T : class Parameters keys IEnumerable<string> cancellationToken CancellationToken Returns Task<Dictionary<string, T>> Type Parameters T SetAsync<T>(string, T, TimeSpan?, CancellationToken) Sets an item in the cache with optional TTL public Task SetAsync<T>(string key, T value, TimeSpan? ttl = null, CancellationToken cancellationToken = default) where T : class Parameters key string value T ttl TimeSpan? cancellationToken CancellationToken Returns Task Type Parameters T SetKeyPrefix(string) Sets a prefix for all cache keys public void SetKeyPrefix(string prefix) Parameters prefix string SetManyAsync<T>(IDictionary<string, T>, TimeSpan?, CancellationToken) Sets multiple items in the cache with optional TTL public Task SetManyAsync<T>(IDictionary<string, T> values, TimeSpan? ttl = null, CancellationToken cancellationToken = default) where T : class Parameters values IDictionary<string, T> ttl TimeSpan? cancellationToken CancellationToken Returns Task Type Parameters T"
  },
  "api/RedisKit.Services.RedisStreamService.html": {
    "href": "api/RedisKit.Services.RedisStreamService.html",
    "title": "Class RedisStreamService | RedisKit",
    "summary": "Class RedisStreamService Namespace RedisKit.Services Assembly RedisKit.dll Implementation of IRedisStreamService using StackExchange.Redis and configurable serialization public class RedisStreamService : IRedisStreamService Inheritance object RedisStreamService Implements IRedisStreamService Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RedisStreamService(IDatabaseAsync, ILogger<RedisStreamService>, RedisOptions) public RedisStreamService(IDatabaseAsync database, ILogger<RedisStreamService> logger, RedisOptions options) Parameters database IDatabaseAsync logger ILogger<RedisStreamService> options RedisOptions Methods AcknowledgeAsync(string, string, string, CancellationToken) Acknowledges a message as processed public Task AcknowledgeAsync(string stream, string groupName, string messageId, CancellationToken cancellationToken = default) Parameters stream string groupName string messageId string cancellationToken CancellationToken Returns Task AddAsync<T>(string, T, int?, CancellationToken) Adds a message to a stream with optional max length for automatic trimming public Task<string> AddAsync<T>(string stream, T message, int? maxLength, CancellationToken cancellationToken = default) where T : class Parameters stream string message T maxLength int? cancellationToken CancellationToken Returns Task<string> Type Parameters T AddAsync<T>(string, T, CancellationToken) Adds a message to a stream public Task<string> AddAsync<T>(string stream, T message, CancellationToken cancellationToken = default) where T : class Parameters stream string message T cancellationToken CancellationToken Returns Task<string> Type Parameters T AddBatchAsync<T>(string, T[], int?, CancellationToken) Adds multiple messages to a stream in batch public Task<string[]> AddBatchAsync<T>(string stream, T[] messages, int? maxLength = null, CancellationToken cancellationToken = default) where T : class Parameters stream string Stream name messages T[] Array of messages to add maxLength int? Optional max length for stream trimming cancellationToken CancellationToken Cancellation token Returns Task<string[]> Array of message IDs Type Parameters T Message type ClaimAsync<T>(string, string, string, long, string[], CancellationToken) Claims ownership of pending messages public Task<Dictionary<string, T?>> ClaimAsync<T>(string stream, string groupName, string consumerName, long minIdleTime, string[] messageIds, CancellationToken cancellationToken = default) where T : class Parameters stream string The stream name groupName string Consumer group name consumerName string Consumer name claiming the messages minIdleTime long Minimum idle time in milliseconds messageIds string[] Message IDs to claim cancellationToken CancellationToken Cancellation token Returns Task<Dictionary<string, T>> Dictionary of claimed messages Type Parameters T CreateConsumerGroupAsync(string, string, CancellationToken) Creates a consumer group for a stream public Task CreateConsumerGroupAsync(string stream, string groupName, CancellationToken cancellationToken = default) Parameters stream string groupName string cancellationToken CancellationToken Returns Task DeleteAsync(string, string[], CancellationToken) Deletes messages from a stream public Task<long> DeleteAsync(string stream, string[] messageIds, CancellationToken cancellationToken = default) Parameters stream string The stream name messageIds string[] Array of message IDs to delete cancellationToken CancellationToken Cancellation token Returns Task<long> Number of messages deleted GetHealthAsync(string, bool, CancellationToken) Gets health information about a stream public Task<StreamHealthInfo> GetHealthAsync(string stream, bool includeGroups = true, CancellationToken cancellationToken = default) Parameters stream string Stream name includeGroups bool Include consumer group information cancellationToken CancellationToken Cancellation token Returns Task<StreamHealthInfo> Stream health information GetInfoAsync(string, CancellationToken) Gets information about a stream public Task<StreamInfo> GetInfoAsync(string stream, CancellationToken cancellationToken = default) Parameters stream string The stream name cancellationToken CancellationToken Cancellation token Returns Task<StreamInfo> Stream information including length, first and last entry IDs, consumer groups GetMetricsAsync(string, string?, TimeSpan?, CancellationToken) Collects metrics about stream operations public Task<StreamMetrics> GetMetricsAsync(string stream, string? groupName = null, TimeSpan? window = null, CancellationToken cancellationToken = default) Parameters stream string Stream name groupName string Optional consumer group name for group-specific metrics window TimeSpan? Time window for rate calculations cancellationToken CancellationToken Cancellation token Returns Task<StreamMetrics> Stream metrics GetPendingAsync(string, string, int, string?, CancellationToken) Gets pending messages for a consumer group public Task<StreamPendingMessageInfo[]> GetPendingAsync(string stream, string groupName, int count = 10, string? consumerName = null, CancellationToken cancellationToken = default) Parameters stream string The stream name groupName string Consumer group name count int Maximum number of pending messages to return consumerName string Optional consumer name to filter by cancellationToken CancellationToken Cancellation token Returns Task<StreamPendingMessageInfo[]> List of pending message information MoveToDeadLetterAsync<T>(string, string, string, string, int, string?, string?, CancellationToken) Moves a failed message to dead letter queue public Task<string> MoveToDeadLetterAsync<T>(string sourceStream, string deadLetterStream, string messageId, string reason, int retryCount = 0, string? groupName = null, string? consumerName = null, CancellationToken cancellationToken = default) where T : class Parameters sourceStream string Source stream name deadLetterStream string Dead letter queue stream name messageId string Message ID to move reason string Reason for moving to DLQ retryCount int Number of retries attempted groupName string Consumer group name consumerName string Consumer name cancellationToken CancellationToken Cancellation token Returns Task<string> Dead letter queue message ID Type Parameters T Message type ReadAsync<T>(string, string?, string?, int, CancellationToken) Reads messages from a stream public Task<Dictionary<string, T?>> ReadAsync<T>(string stream, string? start = null, string? end = null, int count = 10, CancellationToken cancellationToken = default) where T : class Parameters stream string start string end string count int cancellationToken CancellationToken Returns Task<Dictionary<string, T>> Type Parameters T ReadGroupAsync<T>(string, string, string, int, CancellationToken) Reads messages from a stream using consumer group public Task<Dictionary<string, T?>> ReadGroupAsync<T>(string stream, string groupName, string consumerName, int count = 10, CancellationToken cancellationToken = default) where T : class Parameters stream string groupName string consumerName string count int cancellationToken CancellationToken Returns Task<Dictionary<string, T>> Type Parameters T ReadGroupWithAutoAckAsync<T>(string, string, string, Func<T, Task<bool>>, int, CancellationToken) Reads from consumer group with automatic acknowledgment on successful processing public Task<int> ReadGroupWithAutoAckAsync<T>(string stream, string groupName, string consumerName, Func<T, Task<bool>> processor, int count = 10, CancellationToken cancellationToken = default) where T : class Parameters stream string Stream name groupName string Consumer group name consumerName string Consumer name processor Func<T, Task<bool>> Message processor function that returns success/failure count int Number of messages to read cancellationToken CancellationToken Cancellation token Returns Task<int> Number of successfully processed messages Type Parameters T Message type RetryPendingAsync<T>(string, string, string, Func<T, Task<bool>>, RetryConfiguration?, CancellationToken) Retries pending messages that have timed out public Task<RetryResult<T>> RetryPendingAsync<T>(string stream, string groupName, string consumerName, Func<T, Task<bool>> processor, RetryConfiguration? retryConfig = null, CancellationToken cancellationToken = default) where T : class Parameters stream string Stream name groupName string Consumer group name consumerName string Consumer name processor Func<T, Task<bool>> Message processor function retryConfig RetryConfiguration Retry configuration cancellationToken CancellationToken Cancellation token Returns Task<RetryResult<T>> Retry operation result Type Parameters T Message type SetKeyPrefix(string) public void SetKeyPrefix(string prefix) Parameters prefix string TrimByLengthAsync(string, int, bool, CancellationToken) Trims the stream to a specified maximum length public Task<long> TrimByLengthAsync(string stream, int maxLength, bool useApproximateMaxLength = true, CancellationToken cancellationToken = default) Parameters stream string The stream name maxLength int Maximum number of entries to keep useApproximateMaxLength bool Use approximate trimming for better performance cancellationToken CancellationToken Cancellation token Returns Task<long> Number of messages trimmed"
  },
  "api/RedisKit.Services.html": {
    "href": "api/RedisKit.Services.html",
    "title": "Namespace RedisKit.Services | RedisKit",
    "summary": "Namespace RedisKit.Services Classes PubSubService High-performance implementation of IRedisPubSubService with advanced features RedisCacheService Implementation of IRedisCacheService using StackExchange.Redis and configurable serialization RedisStreamService Implementation of IRedisStreamService using StackExchange.Redis and configurable serialization"
  },
  "index.html": {
    "href": "index.html",
    "title": "RedisKit Documentation | RedisKit",
    "summary": "RedisKit Documentation Welcome to RedisKit RedisKit is a production-ready, enterprise-grade Redis toolkit for .NET 9 with advanced caching, pub/sub, and streaming features. Quick Links Getting Started API Documentation GitHub Repository NuGet Package Features \uD83D\uDE80 High-Performance Caching with multiple serializers \uD83D\uDCE1 Advanced Pub/Sub with pattern matching \uD83C\uDF0A Redis Streams support \uD83D\uDEE1️ Enterprise Features including Circuit Breaker ⚡ Blazing Fast - MessagePack 2-3x faster than JSON Installation dotnet add package RedisKit Basic Usage using RedisKit.Extensions; var builder = WebApplication.CreateBuilder(args); builder.Services.AddRedisServices(options => { options.ConnectionString = \"localhost:6379\"; options.Serializer = SerializerType.MessagePack; }); Performance RedisKit uses MessagePack serialization by default, providing: 2.3x faster serialization 5.6x less memory usage 60% smaller payload size Support Report Issues Discussions Wiki"
  }
}